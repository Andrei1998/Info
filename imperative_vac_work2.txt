Imperative Programming Vacation Work 
Andrei-Costin Constantinescu


..........................................................................................
-- Sheet 1 --


Question 1

(a)
def smallestInCommon(a: Array[Int], N: Int, b: Array[Int], M: Int): Int = {
    var i = 0; var j = 0
    // Invariant: 0 <= i <= N and
    //            0 <= j <= M and
    //            a[0 .. i) together with b[0 .. j) are the smallest    
    //                      i + j elements in a and b considered together and 
    //            there is no element common to a[0 .. i) and b[0 .. j).
	while (i < N && j < M && a(i) != b(j)) {
	    if (a(i) < b(j))
	    	i = i + 1
	    else
		    j = j + 1
	}
	a(i) // We know that an answer surely exists, so this is well behaved
}

The program may never access elements of the arrays outside safe bounds
because the only time when array accesses happen is inside the loop body, and
the loop guards together with the invariant read 0 <= i < N, 0 <= j < M.


(b) 
def smallestInCommon(a: Array[Int], N: Int, b: Array[Int], M: Int): Option[Int] = {
    var i = 0; var j = 0
    // Invariant: 0 <= i <= N and
    //            0 <= j <= M and
    //            a[0 .. i) together with b[0 .. j) are the smallest
    //                      i + j elements in a and b considered together and 
    //            there is no element common to a[0 .. i) and b[0 .. j).
    while (i < N && j < M && a(i) != b(j)) {
       if (a(i) < b(j)) 
            i = i + 1
       else
            j = j + 1
    }
    
    // Test whether we've successfully found a common element    
    if (i < N && j < M && a(i) == b(j))
        Some(a(i))
    else
        None
}


(c)
def smallestInCommon(a: Array[Int], N: Int, b: Array[Int], M: Int,
                     c: Array[Int], L: Int): Int = {
    var i = 0; var j = 0; var k = 0
    // Invariant: 0 <= i <= N and
    //            0 <= j <= M and
    //            0 <= k <= L and
    //            a[0 .. i), b[0 .. j) and c[0 .. k) together are the smallest
    //                      i + j + k elements in a, b and c considered together and 
    //            there is no element common to all a[0 .. i), b[0 .. j) and c[0 .. k).
    while (i < N && j < M && k < L && !(a(i) == b(j) && a(i) == c(k))) {
    	if (a(i) <= b(j) && a(i) <= c(k))
    	    i = i + 1
    	else if (b(j) <= a(i) && b(j) <= c(k))
    	    j = j + 1
    	else
            k = k + 1
    }
    a(i) // We know that an answer surely exists, so this is well behaved
}


(d)
def smallestInCommon(as: Array[Array[Int]], n: Array[Int]): Option[Int] = {
    val m = as.size
    val i = new Array[Int](m)
    while (true) {
        // Look for the smallest "head" of the arrays to increment
        var minimum = (as(0)(i(0)), 0)
        var allEqual = true
        for (j <- 0 until m) {
            if (i(j) >= n(j)) // If one of the arrays si finished
                return None
            if (as(j)(i(j)) != as(0)(i(0)))
                allEqual = false
            if (as(j)(i(j)) < minimum._1)
                minimum = (as(j)(i(j)), j)
        }
    
        if (allEqual)
            return Some(minimum._1)
        else
            i(minimum._2) = i(minimum._2) + 1
    }
    Some(-1) // Should never reach this case
}


..........................................................................................


Question 2

(a) 
def record(f: Int => Int, emit: Int => Unit): Unit = {
    var maximum = f(1)
    emit(1)
    var n = 2

    // Invariant: 1 < n and
    //            maximum = max(f[1 .. n)) and
    //            emit was called on all records in [1 .. n),
    //            in ascending order, as required
    while (true) {
        var aux = f(n)
        if (aux > maximum) {
            maximum = aux
            emit(n)
        }
        n = n + 1
    }
}


(b)
def divisors(n: Int): Int = {
    var divs = 0
    // Invariant: 1 <= i <= n + 1 and
    //            divs = the number of divisors
    //                   of n in range [1 .. i)
    for (i <- 1 to n)
        if (n % i == 0)
            divs = divs + 1
    divs
}


(c) Since divisors(n) runs in time O(n) and record will make one call to f = divisors
for all i in [1 .. n], the total time is 1 + 2 + 3 + ... + n = n * (n + 1) / 2 = O(n^2),
so we're dealing with a quadratic growth rate.


(d) Say x is a divisor of n. Then, the only prime factors x may have are p1, p2, ..., pk.
p1's exponent in x may be any integer in range [0 .. i1] - there are (i1 + 1) such choices
p2's exponent in x may be any integer in range [0 .. i2] - there are (i2 + 1) such choices
...
pk's exponent in x may be any integer in range [0 .. ik] - there are (ik + 1) such choices

Most importantly, any combination of these choices makes for a valid divisor of n.
Therefore, by the product rule, n has (i1 + 1)(i2 + 1)...(ik + 1) divisors, as expected.


(e)
def divisors2(n: Int): Int = {
    var divs = 1
    var cpN = n
    var p = 2
    // Invariant: 2 <= p and
    //            cpN = n without all of its
    //                  prime factors < p and
    //            divs = the number of divisors
    //                   of n / cpN
    while (p <= cpN) {
        if (cpN % p == 0) { // p is prime for sure in this case
            var cnt = 1
            cpN = cpN / p
            // Invariant: cnt = the number of p's in
            //                  n / cpN's prime factorization
            while (cpN % p == 0) {
                cpN = cpN / p
                cnt = cnt + 1
            }
            divs *= (cnt + 1)
        }
    }
    divs
}


(f) The second function, divisors2, is, on average, much faster because most numbers have
a few very small prime factors which will be removed from cpN on the first few iterations
of the main while loop, thus greatly reducing the range p has to walk through, as well
as the total number of division operations.


..........................................................................................


Question 3

No supposed to be attempted, as it's part of last year's IP2 paper (which is a course
we're still to study in the term to come).


..........................................................................................


Question 4

(a)
def swap(i: Int, j: Int): Unit = {
    val aux = m(i)
    m(i) = m(j)
    m(j) = aux
}

def backswap(i: Int, j: Int, n: Int): Unit = {
    if (n > 0) {
        swap(i, j)
        backswap(i + 1, j + 1, n - 1)
    }
}


(b)
def reverse(i: Int, n: Int): Unit = {
    if (n > 1) {
        swap(i, i + n - 1)
        reverse(i + 1, n - 2)
    }
}


(c) (i)  
def rotate(i: Int, n: Int, k: Int): Unit = {
    reverse(i, n - k)
    reverse(i + n - k, k)
    reverse(i, n)
}


(ii)
def rotate(i: Int, n: Int, k: Int): Unit = {
    if (0 < k && k < n) {
        if (k < n - k) {
            backswap(i, i + n - k, k)
            rotate(i + k, n - k, k)
        }
        else {
            backswap(i, i + k, n - k)
            rotate(i, k, 2 * k - n)
        }
    }
}


(iii) Since (ii) is tail recursive, we can directly translate it
into an iterative procedure:

def rotate(_i: Int, _n: Int, _k: Int): Unit = {
    var i = _i; var n = _n; var k = _k
    while (0 < k && k < n) {
        if (k < n - k) {
            backswap(i, i + n - k, k)
            i = i + k
            n = n - k
        }
        else {
            backswap(i, i + k, n - k)
            val aux = k
            k = 2 * k - n
            n = aux
        }
    }
}


(iv) 
def rotateBy1(i: Int, n: Int): Unit = {
    val x: T = m(i + n - 1)
    for (j <- i + n - 2 to i by -1)
        m(j + 1) = m(j)
    m(i) = x
}

def rotate(i: Int, n: Int, k: Int): Unit = {
    if (k > 0) {
        rotateBy1(i, n)
        rotate(i, n, k - 1)
    }
}


(d) For simplicity, I will count reads and writes together, naming both of them
"accesses". Note that a swap operation takes 3 accesses.

     (i)   In this case each element takes part in at most 2 swap operations. Thus the
           total cost is 2 * 3 * n  = 6 * n accesses.
(ii / iii) In this case one can note that with every swap operation executed by backswap
           at least one of the two swapped elements ends up in its final position,
           meaning there can be at most n backswap swap operations overall. In turn,
           this means that the rotate procedure will use at most 3 * n access operations
           overall.
    (iv)   This is certainly the worst way to implement rotate. One rotateByOne call
           uses up exactly n + 1 access operations. This means that rotate will make
           exactly k * (n + 1) access operations, which is O(n^2) if k = O(n).


(f) This has been misplaced, it actually belongs to Question 3 above.


..........................................................................................  
-- Sheet 2 --


Question 1

class Tree(val datum: Int, val left: Tree, val right: Tree);


(a)
def preorder(t: Tree): Unit = {
    println(t.datum)
    if (t.left != null)
        preorder(t.left)
    if (t.right != null)
        preorder(t.right)
}


(b)



..........................................................................................


Question 2

(a) heapAt(i) = lchild(i) < N => a(i) >= a(lchild(i)) and
                rchild(i) < N => a(i) >= a(rchild(i))

By definition, this is equivalent to:

    heapAt(i) = 2 * i + 1 < N => a(i) >= a(2 * i + 1) and
                2 * i + 2 < N => a(i) >= a(2 * i + 2)

Now, because i >= N / 2, we deduce that 2 * i + 1 >= N and 2 * i + 2 >= N, so:

    heapAt(i) = True => a(i) >= a(2 * i + 1) and
                True => a(i) >= a(2 * i + 2)

Which is equivalent to:

    heapAt(i) = True and
                True

Or,

    heapAt(i) = True

As expected.


(b) 
// Auxiliary function, swap the values of nodes i and j
def swap(i: Int, j: Int) {
    val aux = a(i)
    a(i) = a(j)
    a(j) = aux
}

// The required function
def siftDown(n: Int, end: Int) = {
    // Invariant: 0 <= n <= end <= N   and
    //            heapAt[n0 .. n)      and
    //            heapAt[n + 1 .. end) and
    //            a is a rearrangement of a0
    while (n < end) {
        val l = lchild(n); val r = rchild(n)
        if (l >= end) // If n has no valid children, then stop
            n = end
        else if (r >= end) { // If n only got a left child
            if (a(l) > a(n)) { // See if swapping n with it is necessary
                swap(n, l) // And either do the swap and continue
                n = l
            }
            else
                n = end   // Or stop, as the heap property is satisfied
        }
        else {
            if (a(l) > a(r)) { // See which of the two children has the larger value
                               // and do swaps accordingly, similar to the former case
                if (a(l) > a(n)) {
                    swap(n, l)
                    n = l
                }
                else
                    n = end
            }
            else {
                if (a(r) > a(n)) {
                    swap(n, r)
                    n = r
                }
                else
                    n = end
            }
        }
    }
}


The idea is to swap n with its son of larger value whenever !heapAt(n), stopping as soon
as heapAt(n) evaluates to true.


(c)
def heapify = {
    // Invariant: -1 <= n < N and
    //            heapAt[(n + 1) .. N) and
    //            a is a rearrangement of a0
    for (n <- (N - 1) to 0 by -1)
        siftDown(n, N)
}


(d) Consider the function parent(n) = (n + 1) / 2 - 1 such that for all 0 < n < N we have
lchild(parent(n)) = n or rchild(parent(n)) = n.
Then, because heapAt holds for all 0 < n < N, we have that a(n) <= a(parent(n)) <=
a(parent(parent(n))) <= ... <= a(0) and so a(0) is the largest element in a[0 .. end).


(e)
def heapsort = {
    heapify
    // Invariant: -1 <= n < N
    //            a is a rearrangement of a0 and
    //            a(n .. N) consists of the largest N - n - 1 elements of a0 and 
    //           heapAt[0 .. n]
    for (n <- (N - 1) to 0 by -1) {
        swap(0, n)
        siftDown(0, n)
    }
}


..........................................................................................


Question 3

(a)
class Node(val datum: Int, val next: ListNode)

class IntList(headNode: Node) {
    def this() = this(null) // The list is initially empty
    ...   
}

I've chosen not to use a dummy header node, as it mostly complicates things in this case,
so headNode will be null for an empty list and its datum will correspond to the first
element of the represented list otherwise.
I've made the default constructor take the header node as a parameter to help in writing
other methods later (e.g. tail and cons).

Now, for a suitable abstraction function, define the metafunction L(node: Node) s.t.:
    L(null) = []
    L(node) = node.datum : L(node.next)

Then,
    Abs: list = L(headNode)

(b)
// Is the list empty?
def isEmpty = headNode == null

// Return the first element of the list
def head = headNode.datum

// Returns a list containing all except the first element of the current list
def tail = new IntList(headNode.next)

// Return a new list containing x followed by the elements of the current list
def cons(x: Int) = new IntList(new Node(x, headNode))


(c)

First, define a helper function (which will also come in handy to solve (d)):


def reverse = {
    // Invariant: ans contains all elements of the list
    //            between headNode and node, exclusive, in reverse order and
    //            node is reachable from headNode by following "next" links
    var node = headNode
    var ans = new IntList
    while (node != null) {
        ans = ans.cons(node.datum)  
        node = node.next
    }
    ans
}

def map(f: Int => Int): IntList = {
    // Invariant: ans contains all elements of the list
    //            between headNode and node, exclusive, in reverse order, with f
    //            applied to their datum before being inserted to ans and
    //            node is reachable from headNode by following "next" links
    var node = headNode
    var ans = new IntList

    while (node != null) {
        ans = ans.cons(f(node.datum))
        node = node.next
    }

    ans.reverse // The list has been built in reverse order, so reverse it
}


(d)
def filter(p: Int => Boolean): IntList = {
    // Invariant: ans contains all elements of the list whose datum satisfies p
    //            between headNode and node, exclusive, in reverse order and
    //            node is reachable from headNode by following "next" links
    var node = headNode
    var ans = new IntList

    while (node != null) {
        if (p(node.datum))
            ans = ans.cons(node.datum)
        node = node.next
    }

    ans.reverse // The list has been built in reverse order, so reverse it 
}


..........................................................................................


Question 4

(a)
def longestFrom(i: Int, j: Int): Int = {
    if (i < N && j < N && a(i) == a(j))
        1 + longestFrom(i + 1, j + 1)
    else
        0
}


(b)
def longestRepeated = {
    var ans(-1, -1, -1)
    for (i <- 0 until N)
        for (j <- i + 1 until N) {
            val longestFr = longestFrom(i, j)
            if (longestFr > ans._3)
                ans = (i, j, longestFr)   
        }
    ans
}

Simply iterate all (i, j) pairs with i != j (WLOG i < j) and compute the largest k such
that a[i .. (i + k)) = b[j .. (j + k)), by calling longestFrom(i, j). Record the pair
(i, j) with the largest k and return the triplet (i, j, k).

Time complexity: O(N^2 * bestk), because O(N^2) (i, j) pairs are being considered and the
                 maximum time longestFrom takes to complete is bestk + O(1).


(c) I will use standard terminology such as the suffix array and the LCP (longest common
prefix).
Consider the following (stronger) result:

If str[0 .. M) are M words, then LCP(str[i], str[j]) with 0 <= i < j < M is maximized
for an (i, j) pair such that i and j are consecutive when str is sorted in lexicographical
order.

To show this, assume WLOG that str is already sorted, then we need to show that
LCP(i, j) can only be maximum when j = i + 1. This is immediate from the observation that
LCP(i, i + 1) <= LCP(i, i + 2) <= ... <= LCP(i, M - 1), which is not hard to prove
formally. But, for an informal argument, consider how words with a common prefix form
a continuous subsequence in str and realize that, for this reason, the two words with the
largest LCP have to be consecutive in the sorted order, as expected.


(d)
def before(i: Int, j: Int) = {
    if (j >= N)
        false
    else if (i >= N)
        true
    else if (a(i) == a(j))
        before(i + 1, j + 1)
    else
        a(i) < a(j)
}

This runs in time O(bestk) worst case.

(e)
def getSuffixArray = {
    val suff = new Array[Int](Int)
    for (i <- 0 until N)
        suff(i) = i
    val orderedSuffixes = suff.sortWith(before)
    orderedSuffixes
}


(f)
def longestRepeated = {
    val suffixArray = getSuffixArray
    ans = (-1, -1, -1)
    for (i <- 0 until N - 1) {
        val longestFr = longestFrom(suffixArray(i), suffixArray(i + 1))
        if (longestFr > ans._3)
            ans = (suffixArray(i), suffixArray(i + 1), longestFr)   
    }
    ans 
}

As guided by the previous parts, we compute the suffix array of a by calling the
appropriate part (e) function and then only consider (i, i + 1) pairs, as showed to be
enough in part (c). The total complexity is O(N * bestk * log N) for the suffix array and
O(N * bestk) for the remaining checks, totalling to O(N * bestk * log N).

Note: 
There are numerous linear time algorithms for computing the suffix array, such as the
classical "mod 3" divide-and-conquer algorithm. Afterwards, the LCP's of the consecutive
entries in the suffix array are known as the "LCP array". Kasai's algorithm is an
ingenious 5 lines long algorithm for computing the LCP array in linear time with constant
additional memory.


..........................................................................................
-- Sheet 3 --


Question 1

(a)
Define Sum [j = a, j = b, expr(j)] = expr(a) + expr(a + 1) + ... + expr(b) and
       Prod[j = a, j = b, expr(j)] = expr(a) * expr(a + 1) * ... * expr(b).


def digsToInt(xs: Array[Int], bs: Array[Int]): Int = {
    // Invariant: -1 <= i < N and
    //            ans = Sum[j = i+1, j = N-1, xs(j) * Prod[k = i+1, k = j-1, bs(k)]]
    var ans = 0
    for (i <- N - 1 to 0 by -1)
        ans = ans * bs(i) + xs(i)
    ans
}

Initialization:
i = N - 1, ans = 0, so the invariant holds true initially.

Invariant maintenance:
ans                 = Sum[j = i+1, j = N-1, xs(j) * Prod[k = i+1, k = j-1, bs(k)]]
ans * bs(i)         = Sum[j = i+1, j = N-1, xs(j) * Prod[k = i,   k = j-1, bs(k)]]
ans * bs(i) + xs(i) = Sum[j = i  , j = N-1, xs(j) * Prod[k = i,   k = j-1, bs(k)]]

So, by executing ans = ans * bs(i) + xs(i), i = i - 1, the invariant is maintained.

(b) 
Pre: 0 <= n < Prod[j = 0, j = N - 1, bs(j)] 
def IntToDigs(n: Int, bs: Array[Int]): Array[Int] = {
    val xs = new Array[Int](N)
    xs(0) = n
    // Invariant 1 <= i <= N + 1 and
    //           for all 0 <= j < i - 1 we have that 0 <= xs(j) < bs(j) and
    //           digsToInt(xs, bs) = n
    for (i <- 1 until N) {
        xs(i)     = xs(i - 1) / bs(i - 1)
        xs(i - 1) = xs(i - 1) % bs(i - 1)
    }
    xs
}

Initialization:
i = 1, xs(0) = n, so the invariant holds true initially.

Invariant maintenance:
Note that performing xs(i) = xs(i - 1) / bs(i - 1), xs(i - 1) = xs(i - 1) % bs(i - 1)
leaves digsToInt(xs, bs) unchanged, as it's simply turning any excess xs(i - 1) into
a smaller amount in xs(i) (e.g. informally, it's exchanging many (>= 60) seconds for fewer
(>= 1) minutes).
With this in mind, coupled with the fact that xs(i - 1) < bs(i - 1) once
xs(i - 1) %= bs(i - 1) has been executed, one can see how the invariant is being
maintained.

Now, overall correctness follows from the fact that n is bounded above (see precondition)
such that the excess left at the end in xs(N - 1) is smaller than bs(N - 1).


..........................................................................................


Question 2

(a) 
/* State: lst: [Int]
 * Init:  lst = []  */
trait ReversableBuffer {
    // Add x to the end of the buffer
    // Post: lst = lst0 ++ [x]
    def append(x: Int)
    
    // Add x to the start of the buffer
    // Post: lst = x : lst0
    def prepend(x: Int)
    
    // Remove and return the i-th element, counting from zero
    // Post: lst = take i lst0 ++ drop (i + 1) lst0 and return lst0 !! i
    def get(i: Int): Int
    
    // Reverse the contents of the buffer
    // Post: lst = reverse lst
    def rev
}


(b)


..........................................................................................


Question 3

(a)
// Pre:  a is an array of integers and
//	 n = a.length
// Post: a is a rearrangement of a0 and
//       a(i) < a(i + 1) for all 0 <= i < n - 1
def sort(a: Array[Int], n: Int)


(b) Helper function that swaps a(i) and a(j):
// Pre: 0 <= i, j < a.size
// Post: a(i) = a0(j) and
//       a(j) = a0(i) and
//       a(k) = a0(k) for all 0 <= k < a.size, k != i, j 
def swap(a: Array[Int], i: Int, j: Int) {
    val aux = a(i)
    a(i) = a(j)
    a(j) = aux
}

Classical ternary partition subroutine:
// Pre: 0 <= l < r < a.size and
//      a(l) = value
// Post: Returns (x, y) and permutes array a such that:
//       All elements 0 <= k < a.size with a0(k) = value are now in [x .. y) and
//       All elements 0 <= k < a.size with a0(k) < value are now in [0 .. x) and
//       All elements 0 <= k < a.size with a0(k) > value are now in [y .. a.size)
def ternaryPartition(a: Array[Int], l: Int, r: Int, value: Int): (Int, Int) = {
    var firstEqual = l
    var lastUnexplored = r - 1 
    var i = l + 1
    // Invariant: a is a permutation of a0 and
    //            1 <= l + 1 <= i <= lastUnExplored + 1 <= r <= a.size and
    //            a[l .. firstEqual) < value and
    //            a[firstEqual .. i) = value and
    //            a(lastUnexplored .. r) > value
    while (i <= lastUnexplored) {
        if (a(i) < value) {
            swap(a, firstEqual, i)
            firstEqual = firstEqual + 1
            i = i + 1
        }
        else if (a(i) > value) {
            swap(a, i, lastUnexplored)
            lastUnexplored = lastUnexplored - 1
        }
        else
            i = i + 1
    }
    (firstEqual, lastUnexplored + 1)
}

Ternary Quicksort:
// Pre: 0 <= l < r <= a.size
// Post: Permutes a[l .. r) into non-decreasing order.
def quickSort(a: Array[Int], l: Int, r: Int): Unit = {
    if (r - l > 1) {
        val pivot = a(l) // Take a(l) to be the pivot
        val split = ternaryPartition(a, l, r, pivot) // Partition around it
        quickSort(a, l, split._1) // Sort all values < pivot
        quickSort(a, split._2, r) // Sort all values > pivot
    }
}

Interface function:
// Pre:  a is an array of integers, n = a.length
// Post: a is a rearrangement of a0 and
//       a(i) < a(i + 1) for all 0 <= i < n - 1
def sort(a: Array[Int], n: Int) = {
    quickSort(a, 0, n)
}

Now, for a very formal proof of correctness one would also need to carefully show how the
invariant is being maintained inside the ternaryPartition function and apply strong
induction on r - l to show that the quickSort function always correctly sorts a[l .. r).


(c) Iterative Ternary Quicksort:
// Pre: 0 <= l < r <= a.size
// Post: Permutes a[l .. r) into non-decreasing order.
def quickSort(a: Array[Int]): Unit = {
    val q = scala.collection.mutable.Queue[(Int, Int)]()
    q.enqueue((0, a.size))
    
    // Invariant: a is a permutation of a0 and
    //            sorting each range a[l .. r) with (l, r) in q
    //            would render a sorted and
    //            any two distinct elements in q are disjoint
    // Variant:   The sum of r - l over (l, r) in q
    while (!q.isEmpty) {
        // (l, r) = q.dequeue
        val aux = q.dequeue
        val l = aux._1
        val r = aux._2
        
        // If not in base case
        if (r - l > 1) {
            val pivot = a(l) // Take a(l) to be the pivot
            val split = ternaryPartition(a, l, r, pivot) // Partition around it
            q.enqueue((l, split._1)) // Sort all values < pivot, later
            q.enqueue((split._2, r)) // Sort all values > pivot, later
        }
    }
}

Also, change the calling function appropriately:
// Pre:  a is an array of integers, n = a.length
// Post: a is a rearrangement of a0 and
//       a(i) < a(i + 1) for all 0 <= i < n - 1
def sort(a: Array[Int], n: Int) = {
    quickSort(a)
}


..........................................................................................


Question 4

(a)
